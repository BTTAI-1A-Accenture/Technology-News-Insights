
                Agree & Join LinkedIn
               
      By clicking Continue to join or sign in, you agree to LinkedIn’s User Agreement, Privacy Policy, and Cookie Policy.
     
                Create your free account or sign in to continue your search
                 
              or
             
      By clicking Continue to join or sign in, you agree to LinkedIn’s User Agreement, Privacy Policy, and Cookie Policy.
     
                New to LinkedIn? Join now
 
                  or
                 
      By clicking Continue to join or sign in, you agree to LinkedIn’s User Agreement, Privacy Policy, and Cookie Policy.
     
              New to LinkedIn? Join now
 Credit cards and personal loans are getting popular nowadays, but underwriting process is still complex and time-consuming due to regulations and risks. Users need to provide a lot of documents such as labor contract, bank statement, household book, ID card, ... and wait for a long time to get approval from bank. It significant impacts to user experience, limits customer base and sale volumes while increase the operation cost. Therefore, digital transformation is inevitable for lending. The biggest challenge with online lending is to prevent fraud effectively while can go mass to open market First of all, we deep dive into some key non functional requirements for online lending workflow Support A/B testing with multiple flows, each flow can have a different banding styles, steps, business rules, ... This is the most important feature, so that we can quickly optimize the journey and rules for each customer segment. Thus reduce drop off, increase the conversion rate and control risk effectively per channel. Furthermore, we can integrate with multiple lenders and partners with their own branding styles and risk appetite Flexibility: Integrate seamlessly with internal and external systems without impact to user experience regardless of its response time, uptime and throughput, ... The lending decision rules require a wide range of input data from external vendors, those systems are slow and not stable. In addition, each lenders uses different dataset and rules.   Scalability: Support realtime processing with high workload, low latency and high accuracy because each application might require to query dozen of data or a large amount of data, for example user images for realtime EKYC. Also it should be able to process a large number of events for realtime fraud prevention Traceability: Ability to quickly trace why a user is approved or rejected. This is not only required for analytic, but also required for customer support to quickly feedback for users Versioning: When a new workflow is approved and activated, existing users are still able to continue with the current workflows  Security: Rules should not be exposed to avoid fraudsters to know decision rules Web: This is a ReactJS application. It calls API to get the current state of an application by its id. Also, submit user's provided data back to the backend via API. To support dynamic workflow, frontend should not handle any workflow logic. It always calls API to know which screen should be shown to user  API: Expose API for frontend, return application state, persist data to database and produce event to brokers (Kafka). The decision output is not returned to frontend, instead API only return the next state (screen) Service Worker: Manage asynchronous tasks. To avoid blocking the user journey, service workers are responsible for listening to state changed events, matching with flow configurations to evaluate whether a data query job need to be triggered, for example CIC, score, ... This is also to optimize cost of query data from external vendors such as CIC by not triggered if some conditions are not met. The collected data will be persisted to data store and also stream (CDC) to Kafka to notify the workflow. This design can also support any data pipeline to produce its processed data to workflow, for example: fraud prevention model Decision Workflow: Gathers queried data from service workers along with user's provided data and other contextual data, feed to decision rules to evaluate application state which can be rejected, approved or a next state. Sometimes, if data is not ready and it is critical for final approval decision, the workflow needs to hold application by moving application to appraising state until that data is ready or reach max configured timeout. We should avoid blocking user journey if data is not ready at a middle step because it significantly increases drop off rate Decision Engine: Rules are defined by a policy language or DSL such as Drools, Grule, go-evaluate, Rego. Our first decision tree was built on top of go-evaluate, but due to the complexity (a few hundreds of rules), it is being migrated to Rego for better documentation. The defined rules will be added to rule repository(database) and cached in-memory to support high traffic with low latency since it is critical for every step of every application (P99 < 3ms)  Configurations: Manage rules, flow definitions and data query configurations. These can be changed on demand by submitting new rules or adjust the existing one.  This section illustrates the detail design of service workers and workflow which are main components of system Service Workers There is a famous framework go-craft to handle background workers in Golang. While its performance is good and easy to handle simple workflows, but it had some drawbacks: Background workers can be handled with Kafka and Temporal as the following diagram A consumer subscribes to a Kafka topic, checks whether configured rules are matched, then triggers an appropriate data processing activity based on configuration. The service configuration can be liked this In the above example, a worker subscribes to state changed event stream, it will trigger querying score if user completed verifying eKYC and rules are satisfied. The triggering rules can be defined as the following example. Rules are optional if not defined, then worker will trigger the job whenever the defined event occurred.  The output will be { "allow": true } if score >= 350. You can try with this playground. This rule will be pushed to decision engine along with other fields such as: name=trigger_query_score, engine_type=rego With this design, when a new data type is required, we only need to add code to integrate with new service, mostly using RestAPI. After that new data type is available for any flow through its configurations Decision Workflow The above diagram is an example of user journey and decision workflow. It consists a set of steps and rules to move between steps. When user starts the journey, engine selects an appropriate flow based on configured strategy (latest, weighted random or round-robin). Decision workflow gathers collected data by service workers in Redis/DB, then feed collected data to decision engine via gRPC/HTTP to get the next state and approval status (rejected/approved). If required data is not ready, workflow holds the process until data is ready or exceeded max waiting time. The flow configuration can be as following example. You can view the output with this playground. The engine will traverse on output tree until node name matches with the current application step name, then get the next state. The input and output will be persisted to database for tracing later. If you look at the output, you can see that all condition variables are included in the output. It is easily to trace back later even application data changed after that User Interface I have described how to configure workflows and decision rules, we can enable a new workflow and its business rules by configurations, but how can end users interact with that workflow? I think that user interfaces should be developed by ReactJS to able to provide a best user experience as possible. There are some frameworks to provide user interface by configuration (no code), but using these framework has some drawbacks as the following I have summarized high level design and concepts of building a dynamic realtime approval workflow. This design scales well because of the following reasons However, it still needs engineers to involve in every setup steps (rules, flows, user interface and automation tests 
        To view or add a comment, sign in
 Stay updated on your professional world 
      By clicking Continue to join or sign in, you agree to LinkedIn’s User Agreement, Privacy Policy, and Cookie Policy.
     
        New to LinkedIn? Join now
 