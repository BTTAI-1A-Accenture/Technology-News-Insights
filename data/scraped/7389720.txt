 Jetpack Compose is Android’s recommended toolkit for building native UIs, representing the platform’s demonstrative shift from imperative to declarative UIs. Google is making a big push to drive adoption, and it’s paying off. As announced at the Android Dev Summit ’22 last October, 160 of the top 1,000 apps on the Google Play store are shipping Jetpack Compose, including companies like Airbnb, Lyft, and Square. Jetpack Compose offers many benefits—it’s more intuitive, requires less code, and accelerates development. But it’s not without its challenges. Moving from an imperative toolkit to Jetpack Compose comes with a learning curve, which is exacerbated by limited documentation, a smaller community, and performance issues. Sentry recently announced their support of Jetpack Compose, with an out-of-the-box integration that allows developers to quickly identify and solve issues in their application. Here’s exactly how Sentry helps teams get started with Jetpack Compose. If you are building a new application from scratch with Jetpack Compose, first download and install Android Studio, an integrated development environment (IDE) optimized for Android apps. Then, create a new project and select either the Empty Compose Activity, which uses Material v2, or Empty Compose Activity (Material3), which uses Material v3. You can see both options in the top right of this screenshot: If you’d like to integrate Jetpack Compose into an existing Android application, add the following build configurations in your app’s build.gradle file. Then, add the Compose BOM (Bill of Materials) and the subset of Compose dependencies to your dependencies. To integrate Sentry into your new Jetpack Compose app, all you need to do is add Sentry’s Gradle plugin in your module’s build.gradle file and perform a Gradle sync afterwards. And then add the necessary values in the AndroidManifest.xml file. These two steps install and configure Sentry into your project. Aside from error reporting, your project now also has automatically instrumented performance monitoring. The Sentry SDK will automatically collect and analyze performance profiles so you can see how your application performs on different user devices in production. By default, Sentry captures all errors and crashes automatically for you. If you want to capture errors and exceptions manually, you can use the captureException method. You have the option to add additional context to all of the errors that happen within your app. That’s arbitrary data that automatically gets attached to the event, and is viewable on the issue details page. To do that, we can attach custom contexts on the current scope like this: This data will now be appended to each issue. We can check it out at the issue details page: Important: There are two limitations you should be aware of. Namely: Just like the additional context, we can also add custom tags on your events, which by contrast are indexed and searchable. You can use tags to quickly access related events and view the tag distribution for a set of events. Common uses for tags include hostname, platform version, and user language. Adding tags is very similar to adding additional contexts. They’re key-value pairs and they can be added to the current scope by using the setTag method. As mentioned, tags are indexed and searchable, so if you add “user-type:premium” in the Custom Search field in the Issues page you’ll see all of the issues that have that tag: Three things to be aware of when working with tags: Adding attachments is yet another way to supplement the events with additional data, and it’s the recommended way if you need to add larger data than contexts and tags. Attachments can be any type of file. To add an attachment, you can either add it to the scope, pass it to any of the capture methods, or manipulate the list of attachments in an EventProcessor or beforeSend. Some rules you need to be aware of when working with attachments: This is probably the simplest way to add attachments. Whenever you’re using one of the capture methods, you can append the attachment as the second argument by using the Hint.withAttachment method. Another way of adding attachments is using the beforeSend callback. This configuration will add the file.txt file to every issue before sending it to the cloud. You can see the attachments for a given issue at the bottom of the issue details page. There’s an Attachments section that lists all attachments and you have the option to delete, download, or preview them. You can also access attachments through the Attachments tab on the same page, where you can view the type of attachment, as well as associated events. You can click the Event ID to open the Issue Details of that specific event. If you’ve provided the Sample Rate value (io.sentry.traces.sample-rate) in your AndroidManifest.xml file, then you’ve already configured Sentry to automatically instrument your application. Sentry will automatically capture transactions for lifecycle events of activities and fragments, cold and warm app start, slow and frozen frames, and other events. It’s also possible to manually instrument a specific function, for example a function that spends some time reshaping a large chunk of data, or a function that obtains data from an API and puts it in the local storage, etc. In order to create custom instrumentations, you’d need to start a transaction by calling the startTransaction method. Warning: Don’t forget to call the finish() method on the transaction, otherwise the transaction won’t be sent to Sentry. If the function you’re trying to instrument is more complex and involves multiple sub-functions that you’d prefer to instrument individually, you can create child spans for each of them and attach them to the main transaction. Don’t forget to call the finish() method on each of the spans before calling the main transaction’s finish() method! If you don’t, they won’t be attached to the main transaction. In conclusion, while Jetpack Compose offers many benefits for building native Android UI, it comes with a steep learning curve and some performance issues. Sentry can help developers get started with Jetpack Compose. As outlined in this article, developers can easily integrate Sentry into their Jetpack Compose applications to capture errors and exceptions, add custom context and tags, get alerted on File I/O issues on the main thread, and utilize performance monitoring. With Sentry, teams can ensure that their Jetpack Compose apps are performing optimally and delivering a great user experience. If you’d like to learn more about what Sentry can do for your application, feel free to visit the documentation, or check out our Sandbox, which is a fully functional version of Sentry that you can play with. Lazar Nikolov is developer relations advocate at Sentry. — New Tech Forum provides a venue to explore and discuss emerging enterprise technology in unprecedented depth and breadth. The selection is subjective, based on our pick of the technologies we believe to be important and of greatest interest to InfoWorld readers. InfoWorld does not accept marketing collateral for publication and reserves the right to edit all contributed content. Send all inquiries to newtechforum@infoworld.com.